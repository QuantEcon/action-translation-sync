/**
 * Code Report Generator for Alignment Diagnostics
 * 
 * Generates detailed code block comparison reports with diffs.
 * This is separate from the structural report for clarity.
 */

import * as fs from 'fs';
import * as path from 'path';
import {
  DiagnosticReport,
  MarkdownAnalysis,
  CodeBlockComparison,
  CodeIntegrity,
  DiffLine,
} from './types';

export interface CodeReportOptions {
  maxDiffLines: number;  // Maximum lines to show in diff (truncate middle)
}

export class CodeReportGenerator {
  private options: CodeReportOptions;

  constructor(options: Partial<CodeReportOptions> = {}) {
    this.options = {
      maxDiffLines: options.maxDiffLines ?? 50,
    };
  }

  /**
   * Generate markdown code report
   */
  toMarkdown(report: DiagnosticReport): string {
    const lines: string[] = [];

    // Header
    lines.push('# Code Block Analysis Report');
    lines.push('');
    lines.push(`**Source**: \`${report.metadata.sourcePath}\`  `);
    lines.push(`**Target**: \`${report.metadata.targetPath}\`  `);
    lines.push(`**Docs Folder**: \`${report.metadata.docsFolder}\`  `);
    lines.push(`**Generated**: ${report.metadata.generatedAt}  `);
    lines.push(`**Tool Version**: ${report.metadata.version}`);
    lines.push('');

    // Summary
    lines.push('## Summary');
    lines.push('');
    lines.push(this.generateSummaryTable(report));
    lines.push('');

    // Scoring methodology
    lines.push('### Score Calculation');
    lines.push('');
    lines.push('```');
    lines.push('Score = (Matched Blocks / Source Blocks) √ó 100%');
    lines.push('');
    lines.push('Match Types:');
    lines.push('  - identical:        Exact match');
    lines.push('  - normalized-match: Same after normalizing strings/comments');
    lines.push('  - modified:         Code differs');
    lines.push('  - missing:          Block in source, not in target');
    lines.push('  - extra:            Block in target, not in source');
    lines.push('');
    lines.push('Diffs show NORMALIZED code:');
    lines.push('  - comments  ‚Üí "# << COMMENT >>"');
    lines.push('  - strings   ‚Üí "<< STRING >>"');
    lines.push('  - captions  ‚Üí "caption: << CAPTION >>"');
    lines.push('This filters out expected translation differences.');
    lines.push('```');
    lines.push('');

    // i18n Legend as table
    const filesWithLocalization = report.markdownAnalysis.filter(
      a => a.codeIntegrity?.localizationNote
    );
    if (filesWithLocalization.length > 0) {
      lines.push('### Localization Notes (üìç i18n)');
      lines.push('');
      lines.push('Files with detected localization patterns (e.g., CJK font configuration):');
      lines.push('');
      lines.push('| File | Patterns Detected | Blocks with Additions |');
      lines.push('|------|-------------------|----------------------|');
      for (const file of filesWithLocalization) {
        const note = file.codeIntegrity!.localizationNote!;
        // Parse the note to extract pattern names and block count
        const patternMatch = note.match(/Localization patterns detected: ([^.]+)/);
        const blockMatch = note.match(/(\d+) block\(s\) have localization additions/);
        const patterns = patternMatch ? patternMatch[1] : note;
        const blocks = blockMatch ? blockMatch[1] : '-';
        lines.push(`| \`${file.file}\` | ${patterns} | ${blocks} |`);
      }
      lines.push('');
    }

    // Detailed file sections
    lines.push('---');
    lines.push('');
    lines.push('## File Details');
    lines.push('');

    const filesWithIssues = report.markdownAnalysis.filter(a => 
      a.codeIntegrity && a.codeIntegrity.score < 100
    );

    if (filesWithIssues.length === 0) {
      lines.push('‚úÖ All files have 100% code block integrity.');
    } else {
      for (const file of filesWithIssues) {
        lines.push(this.generateFileSection(file));
        lines.push('');
      }
    }

    // Footer
    lines.push('---');
    lines.push('*Generated by tool-alignment*');

    return lines.join('\n');
  }

  /**
   * Generate summary table
   */
  private generateSummaryTable(report: DiagnosticReport): string {
    const lines: string[] = [];
    
    // Filter to files with code blocks
    const filesWithCode = report.markdownAnalysis.filter(a => 
      a.codeIntegrity && (a.codeIntegrity.sourceBlocks > 0 || a.codeIntegrity.targetBlocks > 0)
    );

    if (filesWithCode.length === 0) {
      return '*No files with code blocks found.*';
    }

    lines.push('| File | Source | Target | Matched | Modified | Missing | Extra | Score | Notes |');
    lines.push('|------|--------|--------|---------|----------|---------|-------|-------|-------|');

    for (const file of filesWithCode) {
      const ci = file.codeIntegrity!;
      const scoreIcon = ci.score === 100 ? '‚úÖ' : ci.score >= 90 ? 'üü®' : ci.score >= 80 ? 'üü°' : ci.score >= 60 ? 'üü†' : 'üî¥';
      const notes = ci.localizationNote ? 'üìç i18n' : '-';
      
      lines.push(
        `| \`${file.file}\` | ${ci.sourceBlocks} | ${ci.targetBlocks} | ${ci.matchedBlocks} | ${ci.modifiedBlocks} | ${ci.missingBlocks} | ${ci.extraBlocks} | ${scoreIcon} ${ci.score}% | ${notes} |`
      );
    }

    // Overall stats
    const totalSource = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.sourceBlocks || 0), 0);
    const totalTarget = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.targetBlocks || 0), 0);
    const totalMatched = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.matchedBlocks || 0), 0);
    const totalModified = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.modifiedBlocks || 0), 0);
    const totalMissing = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.missingBlocks || 0), 0);
    const totalExtra = filesWithCode.reduce((sum, f) => sum + (f.codeIntegrity?.extraBlocks || 0), 0);
    const overallScore = totalSource > 0 ? Math.round((totalMatched / totalSource) * 100) : 100;

    lines.push('|------|--------|--------|---------|----------|---------|-------|-------|-------|');
    lines.push(
      `| **TOTAL** | **${totalSource}** | **${totalTarget}** | **${totalMatched}** | **${totalModified}** | **${totalMissing}** | **${totalExtra}** | **${overallScore}%** | - |`
    );

    return lines.join('\n');
  }

  /**
   * Generate detailed section for a single file
   */
  private generateFileSection(analysis: MarkdownAnalysis): string {
    const lines: string[] = [];
    const ci = analysis.codeIntegrity!;

    // File header
    lines.push(`### ${analysis.file}`);
    lines.push('');
    
    // Quick summary
    const scoreIcon = ci.score === 100 ? '‚úÖ' : ci.score >= 90 ? 'üü®' : ci.score >= 80 ? 'üü°' : ci.score >= 60 ? 'üü†' : 'üî¥';
    lines.push(`**Summary**: ${ci.sourceBlocks} source ‚Üí ${ci.targetBlocks} target | Score: ${scoreIcon} ${ci.score}%`);
    
    if (ci.localizationNote) {
      lines.push(`  `);
      lines.push(`**üìç i18n**: ${ci.localizationNote}`);
    }
    lines.push('');

    // Only show non-matched blocks
    const nonMatchedBlocks = ci.comparisons.filter(c => 
      c.match !== 'identical' && c.match !== 'normalized-match'
    );

    if (nonMatchedBlocks.length === 0) {
      lines.push('All blocks matched (identical or normalized).');
      return lines.join('\n');
    }

    // Show each non-matched block
    for (const comparison of nonMatchedBlocks) {
      lines.push(this.generateBlockDiff(comparison));
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate diff for a single block comparison
   */
  private generateBlockDiff(comparison: CodeBlockComparison): string {
    const lines: string[] = [];
    const blockNum = comparison.index + 1;
    const matchIcon = this.getMatchIcon(comparison.match);
    
    lines.push(`#### Block ${blockNum} (${comparison.language || 'unknown'}) - ${matchIcon} ${this.formatMatchType(comparison.match)}`);
    lines.push('');

    // Show difference summary
    if (comparison.differences && comparison.differences.length > 0) {
      lines.push(`> ${comparison.differences.join(', ')}`);
      lines.push('');
    }

    // Handle different match types
    if (comparison.match === 'missing') {
      lines.push('**Source block** (missing in target):');
      lines.push('```' + comparison.language);
      lines.push(this.truncateContent(comparison.sourceContent));
      lines.push('```');
    } else if (comparison.match === 'extra') {
      lines.push('**Target block** (not in source):');
      lines.push('```' + comparison.language);
      lines.push(this.truncateContent(comparison.targetContent));
      lines.push('```');
    } else if (comparison.match === 'modified' && comparison.diffLines) {
      // Show diff with only changed lines
      lines.push(this.formatDiff(comparison.diffLines));
    } else {
      // Fallback: show both blocks
      lines.push('**Source**:');
      lines.push('```' + comparison.language);
      lines.push(this.truncateContent(comparison.sourceContent));
      lines.push('```');
      lines.push('');
      lines.push('**Target**:');
      lines.push('```' + comparison.language);
      lines.push(this.truncateContent(comparison.targetContent));
      lines.push('```');
    }

    return lines.join('\n');
  }

  /**
   * Format diff lines, showing only differences
   */
  private formatDiff(diffLines: DiffLine[]): string {
    const lines: string[] = [];
    
    // Filter to only show changed lines with context
    const CONTEXT_LINES = 2;  // Lines of context around changes
    const changedIndices = new Set<number>();
    
    // Find all changed line indices
    diffLines.forEach((line, i) => {
      if (line.type !== 'unchanged') {
        // Add this line and context
        for (let j = Math.max(0, i - CONTEXT_LINES); j <= Math.min(diffLines.length - 1, i + CONTEXT_LINES); j++) {
          changedIndices.add(j);
        }
      }
    });

    if (changedIndices.size === 0) {
      return '*No differences in normalized comparison*';
    }

    lines.push('```diff');
    
    let lastShownIndex = -1;
    const indicesToShow = Array.from(changedIndices).sort((a, b) => a - b);
    let totalLines = 0;
    
    for (const i of indicesToShow) {
      // Check truncation
      if (totalLines >= this.options.maxDiffLines) {
        lines.push(`... (${indicesToShow.length - totalLines} more lines)`);
        break;
      }
      
      // Show ellipsis for gaps
      if (lastShownIndex >= 0 && i > lastShownIndex + 1) {
        lines.push('...');
      }
      
      const line = diffLines[i];
      const prefix = line.type === 'added' ? '+' : line.type === 'removed' ? '-' : ' ';
      lines.push(`${prefix} ${line.content}`);
      
      lastShownIndex = i;
      totalLines++;
    }
    
    lines.push('```');
    
    return lines.join('\n');
  }

  /**
   * Truncate content if too long
   */
  private truncateContent(content: string): string {
    const lines = content.split('\n');
    
    if (lines.length <= this.options.maxDiffLines) {
      return content;
    }

    const halfLines = Math.floor(this.options.maxDiffLines / 2);
    const firstHalf = lines.slice(0, halfLines);
    const secondHalf = lines.slice(-halfLines);
    const omitted = lines.length - this.options.maxDiffLines;
    
    return [
      ...firstHalf,
      `... (${omitted} lines omitted) ...`,
      ...secondHalf,
    ].join('\n');
  }

  /**
   * Get icon for match type
   */
  private getMatchIcon(match: string): string {
    const icons: Record<string, string> = {
      'identical': '‚úÖ',
      'normalized-match': 'üü¢',
      'modified': '‚ö†Ô∏è',
      'missing': '‚ùå',
      'extra': '‚ûï',
    };
    return icons[match] || '‚ùì';
  }

  /**
   * Format match type for display
   */
  private formatMatchType(match: string): string {
    const labels: Record<string, string> = {
      'identical': 'Identical',
      'normalized-match': 'Normalized Match',
      'modified': 'Modified',
      'missing': 'Missing in Target',
      'extra': 'Extra in Target',
    };
    return labels[match] || match;
  }

  /**
   * Write code report to file
   */
  writeReport(report: DiagnosticReport, outputPath: string): string {
    const dir = path.dirname(outputPath);
    const baseName = path.basename(outputPath).replace(/\.(md|json)$/, '');
    const mdPath = path.join(dir, `${baseName}-code.md`);

    // Ensure directory exists
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(mdPath, this.toMarkdown(report));
    return mdPath;
  }
}
